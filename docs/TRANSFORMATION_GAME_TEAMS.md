# üéØ **TRANSFORMATION GAME_TEAMS - PLAN COMPLET**

## üìã **Vue d'ensemble**

Cette transformation vise √† **simplifier et optimiser** la gestion des `game_teams` en :
- ‚ùå **Supprimant** les `freeCards` et `naCards` (NFTs uniquement)
- üîÑ **Fusionnant** `NftRider` et `CardResult` dans un type unifi√©
- üìä **S√©parant** points de base et bonus pour plus de clart√©
- üéØ **Unifiant** la logique entre admin et user backend

---

## üèóÔ∏è **√âTAPE 1 : NOUVEAU SCH√âMA GAME_TEAM**

### **üîß Structures cibles**

#### **Nouveau type unifi√© : NftWithResults**
```typescript
export type NftWithResults = {
  // M√©tadonn√©es NFT (ex-NftRider)
  id: Types.ObjectId;              // ID de la NFT
  role: StatusEnum;                // R√¥le assign√© (leader, climber, etc.)
  pcsRaceId: Types.ObjectId;       // Course assign√©e
  index: number;                   // Position dans l'√©quipe (0-4)
  // ‚ùå SUPPRIM√â : isCaptain (redondant avec gameTeam.captainId)
  
  // R√©sultats int√©gr√©s (ex-CardResult)
  totalPoints: number;             // Total final pour cette NFT
  pointsByType: TeamRiderPoint[];  // Points de base par type
  bonusByType: BonusPoint[];       // Bonus s√©par√©s
};
```

#### **Points de base simplifi√©s**
```typescript
export type TeamRiderPoint = {
  type: MatrixRoleEnum;            // STAGE_RANKING, BREAKAWAY, KOM_POINTS, etc.
  points: number;                  // Points pour le r√¥le assign√© (d√©j√† avec coefficient)
  // ‚ùå Supprim√©: percent, isBonusType (maintenant dans BonusPoint)
};
```

#### **Bonus s√©par√©s pour la transparence**
```typescript
export type BonusPoint = {
  type: RiderBonusPointTypeEnum;   // CAPTAIN, BASED_ON_STATUS, LEVEL_XP, SPECIAL_TYPE
  percent: number;                 // Pourcentage appliqu√© (ex: 25 pour +25%)
  points: number;                  // Points bonus calcul√©s
};
```

#### **Sch√©ma GameTeam simplifi√©**
```typescript
@Schema({ timestamps: true, versionKey: false, collection: 'game_teams' })
export class GameTeam {
  @ApiProperty()
  public _id!: Types.ObjectId;

  // ‚úÖ UNIFI√â : NFTs avec r√©sultats int√©gr√©s
  @Prop({ default: [] })
  public nftIds!: NftWithResults[];

  @Prop()
  public captainId!: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Game' })
  public gameId!: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'GameDivision' })
  public divisionId!: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'UserEntity' })
  public createdBy!: Types.ObjectId;

  // ‚úÖ CALCUL√â : Total de toutes les NFTs
  @Prop({ default: 0 })
  public totalPoint!: number;

  @Prop({ default: 0 })
  public ranking!: number;

  // ‚ùå SUPPRIM√â : 
  // - freeCardIds: NftRider[]
  // - naCardIds: NftRider[]
  // - results: CardResult[]
  // - acquiredResults: CardResult[]
  // - acquiredTotalPoint: number

  // ‚úÖ VIRTUALS conserv√©s (relations Mongoose pour populate)
  public nfts?: Nft[];              // Populate des NFTs compl√®tes
  public division?: GameDivision;   // Populate de la division
  public game?: Game;               // Populate du game complet
}
```

### **üìä Exemple de donn√©es**
```json
{
  "_id": "game_team_123",
  "gameId": "game_456",
  "captainId": "nft_789",
  "nftIds": [
    {
      "id": "nft_789",
      "role": "leader",
      "pcsRaceId": "race_101",
      "index": 0,
      "isCaptain": true,
      "totalPoints": 67.5,
      "pointsByType": [
        { "type": "STAGE_RANKING", "points": 36 },
        { "type": "BREAKAWAY", "points": 9.6 }
      ],
      "bonusByType": [
        { "type": "CAPTAIN", "percent": 25, "points": 11.4 },
        { "type": "BASED_ON_STATUS", "percent": 15, "points": 6.84 }
      ]
    },
    {
      "id": "nft_790",
      "role": "climber", 
      "pcsRaceId": "race_101",
      "index": 1,
      "isCaptain": false,
      "totalPoints": 41.1,
      "pointsByType": [
        { "type": "STAGE_RANKING", "points": 13.5 },
        { "type": "KOM_POINTS", "points": 24 }
      ],
      "bonusByType": [
        { "type": "BASED_ON_STATUS", "percent": 10, "points": 3.75 }
      ]
    }
  ],
  "totalPoint": 108.6
}
```

---

## üîÑ **√âTAPE 2 : SERVICES DE CALCUL (ADMIN BACKEND)**

### **üéØ GameRankingPointService refactoris√©**

#### **M√©thode principale updateGameTeamResults**
```typescript
async updateGameTeamResults(gameId: Types.ObjectId, isAcquired = false) {
  const gameTeams = await this.gameTeamPartitionService.find({ gameId });
  
  for (const gameTeam of gameTeams) {
    const updatedNfts = await this.calculateTeamNftResults(gameTeam, isAcquired);
    const teamTotalPoints = updatedNfts.reduce((sum, nft) => sum + nft.totalPoints, 0);
    
    await this.gameTeamPartitionService.updateOne(
      { _id: gameTeam._id },
      { 
        nftIds: updatedNfts,
        totalPoint: teamTotalPoints 
      }
    );
  }
  
  // Recalculer les rankings
  await this.updateTeamRankings(gameId);
}
```

#### **Calcul des r√©sultats par NFT (OPTIMIS√â)**
```typescript
private async calculateTeamNftResults(
  gameTeam: GameTeam, 
  isAcquired: boolean
): Promise<NftWithResults[]> {
  // 1. ‚úÖ OPTIMISATION : R√©cup√©rer TOUS les r√©sultats de la game en une fois
  const allGameRaceResults = await this.raceResultsService.getGameResults(
    gameTeam.gameId, 
    { isFinal: !isAcquired }
  );
  
  // 2. Calculer pour chaque NFT depuis les donn√©es en m√©moire
  const updatedNfts: NftWithResults[] = [];
  
  for (const nft of gameTeam.nftIds) {
    // Filtrer les r√©sultats pour cette NFT sp√©cifique
    const nftRiderResults = allGameRaceResults.filter(
      result => result.pcsRiderId === nft.riderId && 
                result.raceId === nft.pcsRaceId
    );
    
    // Extraire points pour le r√¥le assign√©
    const rolePoints = this.extractPointsForRole(nftRiderResults, nft.role);
    
    // Calculer bonus (simplifi√©)
    const isCaptain = nft.id.equals(gameTeam.captainId);
    const bonusPoints = await this.calculateNftBonusPoints(nft, rolePoints.total, isCaptain);
    
    // Cr√©er NFT avec r√©sultats
    updatedNfts.push({
      ...nft,
      totalPoints: rolePoints.total + bonusPoints.total,
      pointsByType: rolePoints.byType,
      bonusByType: bonusPoints.byType
    });
  }
  
  return updatedNfts;
}
```

#### **Extraction des points pour un r√¥le**
```typescript
private extractPointsForRole(
  raceResults: DetailedRiderResult[], 
  assignedRole: StatusEnum
): { byType: TeamRiderPoint[], total: number } {
  const pointsByType: TeamRiderPoint[] = [];
  let total = 0;
  
  for (const result of raceResults) {
    for (const riderPoint of result.points) {
      // Trouver le coefficient pour ce r√¥le sp√©cifique
      const roleCoeff = riderPoint.roles.find(r => r.name === assignedRole);
      
      if (roleCoeff && roleCoeff.value > 0) {
        pointsByType.push({
          type: riderPoint.type,
          points: roleCoeff.value  // D√©j√† calcul√© avec coefficient
        });
        total += roleCoeff.value;
      }
    }
  }
  
  return { byType: pointsByType, total };
}
```

#### **Calcul des bonus (UNIFI√â)**
```typescript
private async calculateNftBonusPoints(
  nft: NftWithResults, 
  basePoints: number, 
  isCaptain: boolean
): Promise<{ byType: BonusPoint[], total: number }> {
  const bonusByType: BonusPoint[] = [];
  
  // ‚úÖ Configuration uniforme des bonus
  const bonusConfig = await this.getBonusConfig(nft, isCaptain);
  
  // ‚úÖ Traitement unifi√© pour tous les bonus
  for (const [bonusType, percent] of Object.entries(bonusConfig)) {
    if (percent > 0) {
      const bonusPoints = basePoints * (percent / 100);
      bonusByType.push({
        type: bonusType as RiderBonusPointTypeEnum,
        percent,
        points: bonusPoints
      });
    }
  }
  
  const total = bonusByType.reduce((sum, bonus) => sum + bonus.points, 0);
  return { byType: bonusByType, total };
}

private async getBonusConfig(nft: NftWithResults, isCaptain: boolean) {
  const nftData = await this.nftService.findById(nft.id);
  
  return {
    [RiderBonusPointTypeEnum.CAPTAIN]: isCaptain ? 25 : 0,
    [RiderBonusPointTypeEnum.BASED_ON_STATUS]: await this.getRarityBonusPercent(nftData.rarity),
    [RiderBonusPointTypeEnum.LEVEL_XP]: await this.getLevelBonusPercent(nftData.level),
    [RiderBonusPointTypeEnum.SPECIAL_TYPE]: await this.getSpecialBonusPercent(nftData)
  };
}
```

### **üîÑ Suppression de la logique acquiredResults**
```typescript
// ‚ùå SUPPRIM√â : Plus de distinction acquired/final
// Les r√©sultats sont mis √† jour en temps r√©el dans le m√™me champ

// ‚úÖ NOUVEAU : Un seul appel unifi√©
async updateGameResults(gameId: Types.ObjectId, isLive = false) {
  // isLive d√©termine si on prend les r√©sultats live ou finaux
  await this.updateGameTeamResults(gameId, isLive);
}
```

---

## üéÆ **√âTAPE 3 : CR√âATION/MODIFICATION √âQUIPES (USER BACKEND)**

### **üîß GameTeamService modifications**

#### **Validation stricte : NFTs uniquement**
```typescript
private validateTeamComposition(createTeamDto: CreateTeamDto) {
  // ‚ùå Plus de freeCards ou naCards autoris√©es
  if (createTeamDto.freeCardIds?.length > 0) {
    throw new BadRequestException('Free cards are no longer supported in teams');
  }
  
  if (createTeamDto.naCardIds?.length > 0) {
    throw new BadRequestException('NA cards are no longer supported in teams');
  }
  
  // ‚úÖ Validation NFTs
  if (!createTeamDto.nftIds?.length || createTeamDto.nftIds.length !== 5) {
    throw new BadRequestException('Team must have exactly 5 NFTs');
  }
  
  // Validation r√¥les uniques
  const roles = createTeamDto.nftIds.map(nft => nft.role);
  const uniqueRoles = new Set(roles);
  if (uniqueRoles.size !== roles.length) {
    throw new BadRequestException('Each NFT must have a unique role');
  }
}
```

#### **Cr√©ation d'√©quipe simplifi√©e**
```typescript
async createTeam(createTeamDto: CreateTeamDto, userId: string) {
  // 1. Validation
  this.validateTeamComposition(createTeamDto);
  
  // 2. V√©rifier propri√©t√© des NFTs
  await this.validateNftOwnership(createTeamDto.nftIds, userId);
  
  // 3. Transformer en NftWithResults (sans r√©sultats initialement)
  const nftIds: NftWithResults[] = createTeamDto.nftIds.map((nft, index) => ({
    id: nft.id,
    role: nft.role,
    pcsRaceId: nft.pcsRaceId,
    index,
    isCaptain: nft.id.equals(createTeamDto.captainId),
    totalPoints: 0,        // Sera calcul√© par le service de ranking
    pointsByType: [],      // Sera calcul√© par le service de ranking
    bonusByType: []        // Sera calcul√© par le service de ranking
  }));
  
  // 4. Cr√©er l'√©quipe
  const gameTeam = {
    nftIds,
    captainId: createTeamDto.captainId,
    gameId: createTeamDto.gameId,
    divisionId: createTeamDto.divisionId,
    createdBy: new Types.ObjectId(userId),
    totalPoint: 0,         // Sera calcul√© par le service de ranking
    ranking: 0
  };
  
  const createdTeam = await this.gameTeamPartitionService.create(gameTeam);
  
  // 5. D√©clencher le calcul des points (asynchrone)
  this.eventEmitter.emit('team.created', {
    teamId: createdTeam._id,
    gameId: createTeamDto.gameId
  });
  
  return createdTeam;
}
```

#### **Mise √† jour d'√©quipe**
```typescript
async updateTeam(teamId: string, updateTeamDto: UpdateTeamDto, userId: string) {
  // 1. V√©rifier propri√©t√© de l'√©quipe
  const existingTeam = await this.gameTeamPartitionService.findOne({
    _id: new Types.ObjectId(teamId),
    createdBy: new Types.ObjectId(userId)
  });
  
  if (!existingTeam) {
    throw new NotFoundException('Team not found or not owned by user');
  }
  
  // 2. Validation nouvelle composition
  this.validateTeamComposition(updateTeamDto);
  
  // 3. Transformer les nouvelles NFTs
  const updatedNftIds: NftWithResults[] = updateTeamDto.nftIds.map((nft, index) => ({
    id: nft.id,
    role: nft.role,
    pcsRaceId: nft.pcsRaceId,
    index,
    isCaptain: nft.id.equals(updateTeamDto.captainId),
    totalPoints: 0,        // Sera recalcul√©
    pointsByType: [],      // Sera recalcul√©
    bonusByType: []        // Sera recalcul√©
  }));
  
  // 4. Mettre √† jour
  const updatedTeam = await this.gameTeamPartitionService.updateOne(
    { _id: existingTeam._id },
    {
      nftIds: updatedNftIds,
      captainId: updateTeamDto.captainId,
      totalPoint: 0        // Sera recalcul√©
    }
  );
  
  // 5. D√©clencher recalcul des points
  this.eventEmitter.emit('team.updated', {
    teamId: existingTeam._id,
    gameId: existingTeam.gameId
  });
  
  return updatedTeam;
}
```

### **üì° APIs mises √† jour**

#### **DTOs simplifi√©s**
```typescript
// ‚ùå SUPPRIM√â : freeCardIds, naCardIds
export class CreateTeamDto {
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => NftRiderDto)
  nftIds!: NftRiderDto[];

  @IsMongoId()
  captainId!: string;

  @IsMongoId()
  gameId!: string;

  @IsMongoId()
  divisionId!: string;
}

export class NftRiderDto {
  @IsMongoId()
  id!: string;

  @IsEnum(StatusEnum)
  role!: StatusEnum;

  @IsMongoId()
  pcsRaceId!: string;
}
```

#### **Endpoints adapt√©s**
```typescript
@Post('/teams')
async createTeam(
  @Body() createTeamDto: CreateTeamDto,
  @User() user: UserPayload
) {
  return this.gameTeamService.createTeam(createTeamDto, user.userId);
}

@Put('/teams/:id')
async updateTeam(
  @Param('id') teamId: string,
  @Body() updateTeamDto: UpdateTeamDto,
  @User() user: UserPayload
) {
  return this.gameTeamService.updateTeam(teamId, updateTeamDto, user.userId);
}

@Get('/teams/:id')
async getTeam(@Param('id') teamId: string) {
  return this.gameTeamService.getTeamWithDetails(teamId);
}
```

---

## üñ•Ô∏è **√âTAPE 4 : AFFICHAGE FRONTEND**

### **üé® Composants de cr√©ation d'√©quipe**

#### **S√©lecteur NFT simplifi√©**
```typescript
const CreateTeam = () => {
  const [selectedNfts, setSelectedNfts] = useState<Nft[]>([]);
  const [roleAssignments, setRoleAssignments] = useState<Record<string, StatusEnum>>({});
  const [captain, setCaptain] = useState<string>('');

  // ‚ùå SUPPRIM√â : S√©lection freeCards/naCards
  // ‚úÖ NOUVEAU : Que des NFTs avec assignation de r√¥les

  return (
    <div>
      <h2>Create Team - NFTs Only</h2>
      
      {/* S√©lection des 5 NFTs */}
      <NftSelector 
        maxSelection={5}
        onSelect={setSelectedNfts}
        userNfts={userNfts}
      />
      
      {/* Assignation des r√¥les */}
      <RoleAssignment 
        nfts={selectedNfts}
        assignments={roleAssignments}
        onChange={setRoleAssignments}
        availableRoles={[
          StatusEnum.LEADER,
          StatusEnum.CLIMBER, 
          StatusEnum.SPRINTER,
          StatusEnum.DOMESTIC,
          StatusEnum.FREE_ELECTRON
        ]}
      />
      
      {/* S√©lection du capitaine */}
      <CaptainSelector 
        nfts={selectedNfts}
        selected={captain}
        onChange={setCaptain}
      />
      
      <button onClick={handleCreateTeam}>
        Create Team
      </button>
    </div>
  );
};
```

#### **Composant d'assignation de r√¥les**
```typescript
const RoleAssignment = ({ nfts, assignments, onChange, availableRoles }) => {
  const handleRoleChange = (nftId: string, role: StatusEnum) => {
    // V√©rifier que le r√¥le n'est pas d√©j√† pris
    const currentAssignments = Object.values(assignments);
    if (currentAssignments.includes(role)) {
      toast.error(`Role ${role} is already assigned`);
      return;
    }
    
    onChange({
      ...assignments,
      [nftId]: role
    });
  };

  return (
    <div>
      <h3>Assign Roles</h3>
      {nfts.map(nft => (
        <div key={nft._id} className="nft-role-assignment">
          <img src={nft.imageUrl} alt={nft.name} />
          <span>{nft.name}</span>
          
          <select 
            value={assignments[nft._id] || ''}
            onChange={(e) => handleRoleChange(nft._id, e.target.value as StatusEnum)}
          >
            <option value="">Select Role</option>
            {availableRoles.map(role => (
              <option 
                key={role} 
                value={role}
                disabled={Object.values(assignments).includes(role)}
              >
                {role}
              </option>
            ))}
          </select>
        </div>
      ))}
    </div>
  );
};
```

### **üèÜ Affichage des √©quipes et r√©sultats**

#### **Liste des √©quipes avec d√©tails**
```typescript
const TeamList = ({ gameId }) => {
  const { data: teams } = useGetGameTeams(gameId);

  return (
    <div>
      {teams.map(team => (
        <TeamCard key={team._id}>
          <div className="team-header">
            <h3>Team #{team.ranking}</h3>
            <span className="total-points">{team.totalPoint} pts</span>
          </div>
          
          <div className="team-nfts">
            {team.nftIds.map(nft => (
              <NftResultCard key={nft.id} nft={nft} />
            ))}
          </div>
        </TeamCard>
      ))}
    </div>
  );
};
```

#### **Carte NFT avec r√©sultats d√©taill√©s**
```typescript
const NftResultCard = ({ nft }: { nft: NftWithResults }) => {
  const [showDetails, setShowDetails] = useState(false);

  return (
    <div className="nft-result-card">
      <div className="nft-header">
        <img src={nft.imageUrl} alt={nft.name} />
        <div>
          <h4>{nft.name}</h4>
          <span className="role">{nft.role}</span>
          {nft.isCaptain && <span className="captain">üëë Captain</span>}
        </div>
        <span className="total-points">{nft.totalPoints} pts</span>
      </div>
      
      <button onClick={() => setShowDetails(!showDetails)}>
        {showDetails ? 'Hide' : 'Show'} Details
      </button>
      
      {showDetails && (
        <div className="nft-details">
          {/* Points de base */}
          <div className="base-points">
            <h5>Base Points:</h5>
            {nft.pointsByType.map(point => (
              <div key={point.type} className="point-item">
                <span>{point.type}:</span>
                <span>{point.points} pts</span>
              </div>
            ))}
          </div>
          
          {/* Bonus */}
          <div className="bonus-points">
            <h5>Bonus:</h5>
            {nft.bonusByType.map(bonus => (
              <div key={bonus.type} className="bonus-item">
                <span>{bonus.type}:</span>
                <span>+{bonus.points} pts (+{bonus.percent}%)</span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

#### **Hooks API adapt√©s**
```typescript
// Hook pour r√©cup√©rer les √©quipes
export const useGetGameTeams = (gameId: string) => {
  return useQuery(
    ['game-teams', gameId],
    () => getGameTeams(gameId),
    {
      enabled: !!gameId
      // ‚ùå SUPPRIM√â : refetchInterval (inutile, donn√©es mises √† jour par calculs)
    }
  );
};

// Hook pour cr√©er une √©quipe
export const useCreateTeam = () => {
  const queryClient = useQueryClient();
  
  return useMutation(createTeam, {
    onSuccess: (data) => {
      // Invalider les caches
      queryClient.invalidateQueries(['game-teams']);
      queryClient.invalidateQueries(['user-teams']);
      
      toast.success('Team created successfully!');
    },
    onError: (error) => {
      toast.error(error.message || 'Failed to create team');
    }
  });
};
```

---

## üìä **√âTAPE 5 : MIGRATION DES DONN√âES EXISTANTES**

### **üîÑ Script de migration principal**

```javascript
// Script: migrate-game-teams-structure.js

const { MongoClient } = require('mongodb');

async function migrateGameTeamStructure() {
  console.log('üöÄ Starting GameTeam structure migration...');
  
  const client = new MongoClient(process.env.MONGODB_URI);
  await client.connect();
  const db = client.db();
  
  // Statistiques
  let totalTeams = 0;
  let migratedTeams = 0;
  let skippedTeams = 0;
  let errorTeams = 0;
  
  try {
    // R√©cup√©rer toutes les collections game_teams_YYYY
    const collections = await db.listCollections().toArray();
    const gameTeamCollections = collections
      .filter(col => col.name.startsWith('game_teams_'))
      .map(col => col.name);
    
    console.log(`üìä Found ${gameTeamCollections.length} game_teams collections`);
    
    for (const collectionName of gameTeamCollections) {
      console.log(`\nüîÑ Processing ${collectionName}...`);
      
      const collection = db.collection(collectionName);
      const teams = await collection.find({}).toArray();
      totalTeams += teams.length;
      
      for (const team of teams) {
        try {
          const migratedTeam = await migrateTeamStructure(team);
          
          if (migratedTeam) {
            await collection.replaceOne(
              { _id: team._id },
              migratedTeam
            );
            migratedTeams++;
          } else {
            skippedTeams++;
          }
        } catch (error) {
          console.error(`‚ùå Error migrating team ${team._id}:`, error.message);
          errorTeams++;
        }
      }
    }
    
    console.log('\n‚úÖ Migration completed!');
    console.log(`üìä Statistics:`);
    console.log(`   Total teams: ${totalTeams}`);
    console.log(`   Migrated: ${migratedTeams}`);
    console.log(`   Skipped: ${skippedTeams}`);
    console.log(`   Errors: ${errorTeams}`);
    
  } finally {
    await client.close();
  }
}

async function migrateTeamStructure(team) {
  // V√©rifier si d√©j√† migr√©
  if (team.nftIds && team.nftIds[0]?.totalPoints !== undefined) {
    console.log(`‚è≠Ô∏è  Team ${team._id} already migrated`);
    return null;
  }
  
  // Convertir ancien format vers nouveau
  const newNftIds = [];
  
  // ‚úÖ Migrer les NFTs existantes
  if (team.nftIds && team.nftIds.length > 0) {
    for (let i = 0; i < team.nftIds.length; i++) {
      const nft = team.nftIds[i];
      
      newNftIds.push({
        id: nft.id,
        role: nft.role,
        pcsRaceId: nft.pcsRaceId,
        index: nft.index || i,
        isCaptain: nft.id.equals ? nft.id.equals(team.captainId) : nft.id.toString() === team.captainId?.toString(),
        totalPoints: 0,      // Sera recalcul√© par le service
        pointsByType: [],    // Sera recalcul√© par le service
        bonusByType: []      // Sera recalcul√© par le service
      });
    }
  }
  
  // ‚ùå Ignorer freeCardIds et naCardIds
  if (team.freeCardIds?.length > 0 || team.naCardIds?.length > 0) {
    console.log(`‚ö†Ô∏è  Team ${team._id} has freeCards/naCards - will be ignored`);
  }
  
  // Cr√©er la nouvelle structure
  const migratedTeam = {
    _id: team._id,
    nftIds: newNftIds,
    captainId: team.captainId,
    gameId: team.gameId,
    divisionId: team.divisionId,
    createdBy: team.createdBy,
    totalPoint: 0,       // Sera recalcul√©
    ranking: 0,          // Sera recalcul√©
    createdAt: team.createdAt,
    updatedAt: new Date()
  };
  
  console.log(`‚úÖ Migrated team ${team._id} with ${newNftIds.length} NFTs`);
  return migratedTeam;
}

// Ex√©cuter la migration
if (require.main === module) {
  migrateGameTeamStructure()
    .then(() => process.exit(0))
    .catch(error => {
      console.error('üí• Migration failed:', error);
      process.exit(1);
    });
}

module.exports = { migrateGameTeamStructure };
```

### **üßπ Script de nettoyage post-migration**

```javascript
// Script: cleanup-old-game-team-fields.js

async function cleanupOldGameTeamFields() {
  console.log('üßπ Cleaning up old GameTeam fields...');
  
  const client = new MongoClient(process.env.MONGODB_URI);
  await client.connect();
  const db = client.db();
  
  try {
    const collections = await db.listCollections().toArray();
    const gameTeamCollections = collections
      .filter(col => col.name.startsWith('game_teams_'))
      .map(col => col.name);
    
    for (const collectionName of gameTeamCollections) {
      console.log(`üîÑ Cleaning ${collectionName}...`);
      
      const result = await db.collection(collectionName).updateMany(
        {},
        {
          $unset: {
            freeCardIds: "",
            naCardIds: "",
            results: "",
            acquiredResults: "",
            acquiredTotalPoint: ""
          }
        }
      );
      
      console.log(`‚úÖ Cleaned ${result.modifiedCount} documents in ${collectionName}`);
    }
    
  } finally {
    await client.close();
  }
}
```

---

## üéØ **√âTAPES D'IMPL√âMENTATION D√âTAILL√âES**

### **Phase 1 : Sch√©mas et Types (1-2 jours)**
1. ‚úÖ **Modifier `game-team.schema.ts`**
   - Cr√©er types `NftWithResults`, `BonusPoint`
   - Supprimer anciens champs
   - Mettre √† jour les virtuals

2. ‚úÖ **Mettre √† jour les DTOs**
   - `CreateTeamDto`, `UpdateTeamDto`
   - Supprimer `freeCardIds`, `naCardIds`
   - Validation stricte NFTs uniquement

3. ‚úÖ **Tests unitaires des types**
   - Validation des nouveaux types
   - Tests de s√©rialisation/d√©s√©rialisation

### **Phase 2 : Services Backend (3-4 jours)**
4. üîÑ **Adapter `GameRankingPointService` (Admin)**
   - Refactorer `updateGameTeamResults`
   - Impl√©menter `extractPointsForRole`
   - Impl√©menter `calculateNftBonusPoints`
   - Supprimer logique `acquiredResults`

5. üîÑ **Adapter `GameTeamService` (User)**
   - Validation stricte composition √©quipe
   - Cr√©ation/modification NFTs uniquement
   - Gestion des √©v√©nements pour recalcul

6. üîÑ **Mettre √† jour `GameTeamPartitionService`**
   - Support des nouveaux types
   - Optimisations requ√™tes

### **Phase 3 : APIs (2-3 jours)**
7. üîÑ **Controllers Admin Backend**
   - Endpoints calcul des points
   - Endpoints gestion des games
   - Tests d'int√©gration

8. üîÑ **Controllers User Backend**
   - Endpoints cr√©ation/modification √©quipes
   - Endpoints consultation √©quipes
   - Validation et gestion d'erreurs

9. üîÑ **Tests API complets**
   - Tests end-to-end
   - Tests de performance
   - Tests de validation

### **Phase 4 : Frontend (4-5 jours)**
10. üîÑ **Composants cr√©ation √©quipe**
    - `NftSelector` (NFTs uniquement)
    - `RoleAssignment` (assignation r√¥les)
    - `CaptainSelector`
    - Validation c√¥t√© client

11. üîÑ **Composants affichage √©quipes**
    - `TeamList` avec nouveaux r√©sultats
    - `NftResultCard` d√©taill√©
    - S√©paration points base/bonus
    - Indicateurs visuels

12. üîÑ **Hooks et services API**
    - Adaptation des appels API
    - Gestion du cache
    - Gestion des erreurs

### **Phase 5 : Migration & Tests (2-3 jours)**
13. üîÑ **Scripts de migration**
    - Migration structure donn√©es
    - Nettoyage anciens champs
    - V√©rification int√©grit√©

14. üîÑ **Tests complets**
    - Tests de r√©gression
    - Tests de performance
    - Tests utilisateur

15. üîÑ **D√©ploiement progressif**
    - D√©ploiement staging
    - Tests production
    - Rollback plan

---

## ‚ùì **QUESTIONS CRITIQUES AVANT D√âMARRAGE**

### **üö® Gestion des √©quipes existantes**
1. **Que faire des √©quipes avec freeCards/naCards ?**
   - Option A : Les invalider (forcer recr√©ation)
   - Option B : Les convertir automatiquement (garder que les NFTs)
   - Option C : P√©riode de gr√¢ce avec migration manuelle

2. **Impact sur les games en cours ?**
   - Faut-il attendre la fin des games actuels ?
   - Ou migrer en live avec recalcul des points ?

### **üîÑ Ordre d'impl√©mentation**
3. **Par o√π commencer ?**
   - Admin backend d'abord (calculs) ?
   - User backend d'abord (cr√©ation) ?
   - Frontend d'abord (validation UX) ?

4. **Strat√©gie de d√©ploiement ?**
   - Big bang ou progressif ?
   - Feature flags pour rollback ?

### **üìä Performance et monitoring**
5. **Impact performance ?**
   - Les nouveaux calculs sont-ils plus lourds ?
   - Faut-il pr√©voir du cache suppl√©mentaire ?

6. **Monitoring ?**
   - M√©triques √† surveiller pendant la migration ?
   - Alertes √† mettre en place ?

---

## üéØ **PR√äT √Ä D√âMARRER ?**

Ce plan d√©taille **toutes les √©tapes** de la transformation des `game_teams`. 

**Validation finale :**
- ‚úÖ Suppression freeCards/naCards
- ‚úÖ Fusion NftRider + CardResult
- ‚úÖ S√©paration points base/bonus
- ‚úÖ Unification admin/user backend
- ‚úÖ Migration donn√©es existantes
- ‚úÖ Tests complets

**√ätes-vous pr√™t √† commencer par l'√âtape 1 (Sch√©mas) ?** üöÄ
